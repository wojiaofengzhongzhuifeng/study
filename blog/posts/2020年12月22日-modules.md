# 模块化

## 简单模块化发展过程

- 模块化发展过程，以加减计数器为例

  需求：完成一个计数器，可以对数据进行加减操作

- 原始写法

  ```javascript
  // 定义
  var count = 0;
  function addCount(){
  	count += 1
  }
  function minusCount(){
  	count -= 1
  }
  
  // 使用
  addCount()
  console.log(count)
  ```

- 对象写法

  ```javascript
  // 定义
  var countModule = {
  	count: 0,
  	addCount: function(){
  		this.count += 1
  	},
  	minusCount: function(){
  		this.count -= 1
  	},
  }
  
  // 使用
  countModule.addCount()
  console.log(countModule)
  ```

- 立即执行函数 + 闭包隐藏私有变量

  ```javascript
  // 定义
  var module = function (){
  	var count = 0
  	function addCount(){
  		count += 1
  	}
  	function minusCount(){
  		count -= 1
  	}
  	function getCount(){
      return count
  	}
  	return {
  		addCount,
  		minusCount,
  		getCount,
  	}
  }()
  
  // 使用
  module.addCount()
  console.log(module.getCount())
  ```

- 模块依赖

  ```javascript
  // 加减定义
  var module = function (){
  	var count = 0
  	function addCount(){
  		count += 1
  	}
  	function minusCount(){
  		count -= 1
  	}
  	function getCount(){
      return count
  	}
    function setCount(newCount){
      count = newCount
    }
  	return {
  		addCount,
  		minusCount,
  		getCount,
      setCount
  	}
  }()
  
  // 定义 2 
  module = (function(module){
  	module.sayCount = function(){
      console.log('当前 count', module.getCount())
    }
    module.multipleCount = function(number){
      let multipledCount = module.getCount() * number
      module.setCount(multipledCount)
    }
    return module
  })(module)
  
  // 使用
  module.addCount()
  module.multipleCount(4)
  module.getCount()
  ```

## 各种模块化解决方案

- CommonJS

  在 Node.js 使用，同步加载模块

  ```
  var math = require('math');
  math.add(2, 3);
  ```

- AMD

  在浏览器使用，异步加载模块

  ```
  require(['math'], function (math) {
  	math.add(2, 3);
  });
  ```

- CMD
- UMD
- ES Modules





## AMD与 CMD 的区别

|              | AMD                        | CMD                        |
| ------------ | -------------------------- | -------------------------- |
| 依赖处理方式 | 全部依赖加载完毕，执行回调 | 遇到依赖加载，才去加载依赖 |

```javascript
// AMD
define(['a', 'b'], function(a, b) {
    a.todo()
    // 虽然 b.todo() 没有执行到，但 b模块 还是提前加载执行完毕了
    if (false) {b.todo()} 
})

// CMD
define(function(require, exports, module) {
    var a = require('./a') //需要时再执行
    a.todo()

    if (true) {
        var b = require('./b')
        b.todo()
    }
})

```



## ES Modules 与 CommonJS 的区别

- 

