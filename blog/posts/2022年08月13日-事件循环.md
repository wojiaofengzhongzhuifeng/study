### 关键词

事件循环、线程、进程、宏任务、微任务、任务队列、同步/异步、阻塞/非阻塞、事件循环event loop、call stack 调用栈、queue 队列

---



### 直播知识点

- js 是单线程、浏览器是多线程

- js 是单线程，如何实现异步

  异步是浏览器实现的

- js 在异步中，只会向其他线程添加添加任务；执行回调

- 宏任务对应多个线程；

- 异步执行原理的通过事件驱动完成

- 数据驱动 、 事件驱动

  事件驱动：代码提前定义事件回调函数；等待用户 + 代码触发；类似于监听按钮点击事件

  数据驱动：



---

### 笔记知识点

-  js 是单线程的，为什么能执行异步任务？
  - 浏览器的构成是由多个进程构成（渲染进程等）
  - 每开一个 tab 是一个独立的渲染进程
  - 渲染进程包括 JS 引擎线程 、HTTP 请求线程、定时器线程等
  - 异步任务 === JS 引擎线程将异步任务交给其他线程处理，JS 引擎线程处理异步任务的回调结果
  - 异步任务并不是 JS 处理的，而是浏览器协调多个线程实现的
- 事件循环 事件驱动 异步任务的关系
- 宏任务、微任务的理解
  - 事件循环执行顺序：同步任务 => 微任务 => 宏任务
  - 微任务不需要其他线程支持；宏任务需要其他线程
  - 宏任务有多个任务队列（http 请求队列，定时器队列）；微任务只有一个任务队列
- 任务队列保存的一定是回调函数
- 任务队列分为微任务队列和宏任务队列
- **执行函数时，将该函数压入call stack，待函数执行完毕后，将函数推出 call stack **
- 遇到 setTimeout 会立即推入 callstack ，但是立即被推出
- concurrency 并发性
- diagram 图示，图例
- identical 一致
- 

---

### 笔记

---

### 练习题

---

```javascript
var flag = false
setInterval(function(){
  flag = true;
  console.log('interval')
}, 1000)
while(flag){
   console.log('running')// 【新知识】同步执行完毕，
}
```

```javascript
async function promise1() {
  console.log('promise 1-1')
  await promise2(); // 【新知识】promise2 函数内部是同步执行；后面的内容作为 then 的内容
  console.log('promise 1-2')
  await promise3();
  console.log('promise 1-3')
}
async function promise2() {
  console.log('promise2');
}
async function promise3() {
  console.log('promise3');
}
promise1(); // 【新知识】如果 async 函数在调用的时候没有 await ，那么后面的内容是同步的
new Promise((resolve) => {
  console.log('promise4');
  resolve()
}).then(() => {
  console.log('100');
})
```

