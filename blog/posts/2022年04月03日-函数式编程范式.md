## 知识结构图

- 什么是函数式编程
- 函数相关复习
  - 函数是一等公民
  - 高级（高阶）函数
  - 闭包
- 函数式编程基础
  - lodash
  - 纯函数
  - 柯里化
  - 管道
  - 函数组合
- 函子
  - Functor
  - MayBe
  - Either
  - IO
  - Task
    - folktale
  - Monad



## 新知识点

- 函数式编程的意思是以函数作为最小单位进行编程（与面向对象编程比较）

- 函数式编程的函数指的是数学的函数，表示的是输入与输出的映射关系 => 一个输入对应一个输出

- 为什么要把函数1 作为函数 2 的参数？
  
  让参数更加灵活
  
- 函数作为返回值的意义是什么？

  实现 once 

- 没有彻底理解once 的实现

- 最简单的闭包

  ```
  function outFn(){
  	let msg = "inner variable"
  	return function innerFn(){
  		console.log(msg)
  	}
  }
  ```

  

- 闭包特点

  变量不会被释放

  延长变量msg的作用范围

- 闭包的本质

  函数outFn在执行的时候会放到一个执行栈，当函数outFn执行完毕后会从执行栈溢出，但是堆上的作用域成员msg因为被外部函数innerFn引用不能释放，因此 innerFn 依然可以访问msg 

- 通过调试器查看闭包

- ###### 纯函数特点

  - 对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用
  - 函数内部不会使用外部的变量，如 window，localStorage 之类，只有输入变量
  - 没有副作用

- 纯函数的优点

  - 可缓存
  - 可测试
  - 并行处理
    - 在多线程环境下并行操作共享的内存数据很可能出现意外情况
    - 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数

- call apply this arguments

- 柯里化概念

  - 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
  - 然后返回一个新的函数接受剩余参数，返回结果

- 通过柯里化可以解决纯函数硬编码的问题

  ```
  // 第一版纯函数
  function checkAge(age){
  	let min = 18 // 存在硬编码，需要优化
  	return age >= min
  }
  let isLimit = checkAge(20)
  
  // 第二版纯函数
  function checkAge(age, min){
  	return age >= min
  }
  let isLimit1 = checkAge(20, 18)
  let isLimit2 = checkAge(25, 18)
  
  // // 第三版纯函数
  function createCheckAgeFn(min){
  	return function checkAge(age){
  		return age >= min
  	}
  }
  let checkAge18 = createCheckAgeFn(18)
  let isLimit1 = checkAge18(20)
  let isLimit2 = checkAge18(25)
  ```

- 柯里化的例子：获取数组中含空格字符串

- 柯里化函数实现 《柯里化原理模拟》

  原理：达到函数参数个数，调用函数；否则返回带有参数的函数

  重点：如何收集参数？

  ```
  function curry(func){
  	return function curriedFn(...args){
  		if(args.length < func.length){
  			return function(){
  				return curriedFn(...args.concat(Array.from(arguments)))
  			}
  		}
  		return func(...args)
  	}
  }
  // 使用
  function getSum(a, b, c){
  	return a + b + c
  }
  var curriedGetSum = curry(getSum)
  
  // 参数个数一次性传入
  var result1 = curriedGetSum(100, 300, 600)
  console.assert(result1 === 1000)
  
  // 参数个数分多次传入
  var curriedGetSum100 = curriedGetSum(100)
  var curriedGetSum300 = curriedGetSum100(200)
  var result2 = curriedGetSum300(600)
  console.assert(result2 === 900)
  ```

  理解：

  - ...args 是实际传入的参数
  - func 是 getSum 
  - arguments 是匿名函数的参数
  - args.length 是实际参数，对应 100，200，600；func.length 是形式参数，对应 a,b,c

- 柯里化是对函数参数的**缓存**，把多参数单函数变成单参数多函数

- compose 英文组合

- 函数组合的执行顺序是从右到左，和 webpack 配置一致，为什么？

- 函数组合的子函数必须是单参数函数

- 函数组合的实现原理

  ```
  function compose(...args){
  	return function(value){
  		// reduce 第一个参数是一个函数A，函数A的第一个参数是函数 A 的返回值；
  		// 函数 A 的第二个参数是 args 每一项，也就是每个函数
  		return args.reverse().reduce(function (累计值, 子函数){
  			return 子函数(累计值)
  		}, value)
  	}
  }
  
  // 需求：获取字符串数组最后一项，并且转化为大写
  // 使用
  const reverse = arr => arr.reverse()
  const getFirstItem = arr => arr[0]
  const toUpper = string => string.toUpperCase()
  
  const fn = compose(toUpper, getFirstItem, reverse)
  const result = fn(["a", "b", "ac"])
  console.assert(result === "AC")
  ```

- 如何调试函数组合

- 使用 lodash 完成需求： NEVER SAY DIE 转换为 never say die

- loadsh FP 模块特点

  - 数据滞后
  - 函数自动 curry 化

  ```
  const _ = require("lodash")
  const fp = require("lodash/fp")
  
  // 需求 1 : 将 string[] uppCase
  
  // 不使用 FP 模块
  var result1 = _.map(['a', 'b', 'c'], _.upperCase)
  console.assert(JSON.stringify(result1) === JSON.stringify(['A', 'B', 'C']))
  
  // 使用 FP 模块 - 数据滞后特点
  var result2 = fp.map(fp.toUpper, ['a', 'b', 'c'])
  console.assert(JSON.stringify(result2) === JSON.stringify(['A', 'B', 'C']))
  
  // 使用 FP 模块 - 函数自动 curry
  var upperStringArrayFn = fp.map(fp.toUpper)
  var result3 = upperStringArrayFn(['a', 'b', 'c'])
  console.assert(JSON.stringify(result3) === JSON.stringify(['A', 'B', 'C']))
  
  ```

- 《Lodash-map 方法的小问题》

  _.map(["23", "8", "10"], parseInt) 出现的问题？ 与  [1,2,3].map(parseInt) 一致

  fp.map(parseInt, ["23", "8", "10"]) 是正常的

- pointFree 是什么

  https://www.ruanyifeng.com/blog/2017/03/pointfree.html

  - 不需要指明处理的数据
  - 只需要合成运算过程
  - 需要定义一些辅助的基本运算函数

- 函数式编程最大的用处是优化处理数据过程？

- pointFree 示例

  ```
  const fp = require("lodash/fp")
  
  // 1. 以空格分隔字符串
  // 2. 获取字符串第一个
  // 3. 大写
  // 4. 拼接
  // world wild web => W.W.W
  
  const fn = fp.flowRight(fp.join(". "), fp.map(fp.first), fp.map(fp.upperCase), fp.split(" "))
  console.log(fn("world wild web"));
  
  ```

  

- 函子

  - 函数式变成的运算不直接操作值，而是有函子完成
  - 函子就是一个实现 map 契约的对象
  - 把函子想象成盒子，盒子内封装一个值
  - 想要处理盒子内的值，我们需要给盒子的map 方法传递一个处理值的函数（纯函数），由这个函数对值进行处理
  - 最终 map 方法返回一个包含新值的盒子（函子）

- functor 函子的实现

  ```
  // 函子定义
  class Container{
  	static of(value){
  		return new Container(value)
  	}
  	constructor(value){
  		this._value = value
  	}
  	map(fn){
  		return Container.of(fn(this._value))
  	}
  }
  
  // 使用
  let r = Container.of(5).map(x => x + 1).map(x => x * x)
  console.log(r._value) // 36
  ```

- MayBe 函子的实现

  ```
  class MayBe{
  	static of(value){
  		return new MayBe(value)
  	}
  	constructor(value){
  		this._value = value
  	}
  	map(value){
  		return this.isFalsy() ? MayBe.of(null) : MayBe.of(this._value)
  	}
  	isFalsy(){
  		return this._value === null || this._value === undefined
  	}
  }
  
  let r1 = MayBe.of("Hello word").map(x=>x.toUpperCase)
  let r2 = MayBe.of(null).map(x=>x.toUpperCase)
  ```

- either 函子

  处理异常副作用，保证函数是纯函数

  ```
  // 错误函子
  class Left{
  	static of(value){
  		return new Left(value)
  	}
  	constructor(value){
  		this._value = value
  	}
  	map(fn){
  		return this
  	}
  }
  
  // 正确函子
  class Right{
  	static of(value){
  		return new Right(value)
  	}
  	constructor(value){
  		this._value = value
  	}
  	map(fn){
  		return Right.of(fn(this._value))
  	}
  }
  
  function parseJSON(str){
  	try{
  		return Right.of(JSON.parse(str))
  	} catch(e){
  		return Left.of({error: e.message})
  	}
  }
  
  let r1 = parseJSON(`{name: "xm"}`)
  let r2 = parseJSON(`{"name": "xm"}`)
  
  ```

- IO 函子

  - IO 函子中的 _value 是一个函数，这里是把函数作为值来处理
  - IO 函子可以把不纯的动作存储到 _value  中，延迟执行这个不纯的操作（惰性执行），保证当前的操作纯粹
  - 把不纯的操作交由调用者处理

- IO 函子的实现

  ```
  // IO 函子
  const fp = require('lodash/fp')
  
  class IO {
    static of (value) {
      return new IO(function () {
        return value
      })
    }
  
    constructor (fn) {
      this._value = fn
    }
  
    map (fn) {
      return new IO(fp.flowRight(fn, this._value))
    }
  }
  
  // 调用
  let r = IO.of(process).map(p => p.execPath)
  // console.log(r)
  console.log(r._value())
  ```

- folktale 基本使用

  ```
  // folktale 中的 compose、curry
  const { compose, curry } = require('folktale/core/lambda')
  const { toUpper, first } = require('lodash/fp')
  // let f = curry(2, (x, y) => {
  //   return x + y
  // })
  
  // console.log(f(1, 2))
  // console.log(f(1)(2))
  
  
  let f = compose(toUpper, first)
  console.log(f(['one', 'two']))
  ```

- folktale 使用异步函子解决异步任务

  ```
  // Task 处理异步任务
  const fs = require('fs')
  const { task } = require('folktale/concurrency/task')
  const { split, find } = require('lodash/fp')
  
  function readFile (filename) {
    return task(resolver => {
      fs.readFile(filename, 'utf-8', (err, data) => {
        if (err) resolver.reject(err)
  
        resolver.resolve(data)
      })
    })
  }
  
  readFile('package.json')
    .map(split('\n'))
    .map(find(x => x.includes('version')))
    .run()
    .listen({
      onRejected: err => {
        console.log(err)
      },
      onResolved: value => {
        console.log(value)
      }
    })
  ```

- 如何解决纯函数副作用的问题？

  抛出钩子函数，让用户进行处理

- monad

  ```
  // IO Monad
  const fs = require('fs')
  const fp = require('lodash/fp')
  
  class IO {
    static of (value) {
      return new IO(function () {
        return value
      })
    }
  
    constructor (fn) {
      this._value = fn
    }
  
    map (fn) {
      return new IO(fp.flowRight(fn, this._value))
    }
  
    join () {
      return this._value()
    }
  
    flatMap (fn) {
      return this.map(fn).join()
    }
  }
  
  let readFile = function (filename) {
    return new IO(function () {
      return fs.readFileSync(filename, 'utf-8')
    })
  }
  
  let print = function (x) {
    return new IO(function () {
      console.log(x)
      return x
    })
  }
  
  let r = readFile('package.json')
            // .map(x => x.toUpperCase())
            .map(fp.toUpper)
            .flatMap(print)
            .join()
  
  console.log(r)
  ```

