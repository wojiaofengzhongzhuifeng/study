# 面向对象

## 串联过程

- 使用_new 创建实例对象
- 使用 es5 实现继承
- 使用 _instanceof 判断实例对象的从属
- 判断实例对象的原型链关系

## 使用 _new 创建实例对象

### 核心

- 创建临时对象
- 临时对象指向构造函数的公共属性
- **借用**构造函数代码，为临时对象设置实例属性值
- 返回临时对象

### 代码

https://codesandbox.io/s/optimistic-silence-ood8vv

## 使用 es5 实现继承

### 代码

https://codesandbox.io/s/interesting-sanne-z9bml

### 问题

1. 组合继承/完美继承时， 为什么不直接Student.prototype = Person.prototype，而是要Student.prototype = new Person() / new F()？

   Student.prototype.study 的 study 方法会在 Person，而不是 Student 中

   https://jsbin.com/kugogogugo/1/edit?js,console,output

## 使用 _instanceof 判断实例对象的从属关系

### 核心

```javascript
// 假设判断 s1 instanceof Object, 实际执行的判断如下
s1.__proto__ === Object.prototype // false
s1.__proto__.__proto__ === Object.prototype // false
s1.__proto__.__proto__.__proto__ === Object.prototype // true
```

### 代码

https://codesandbox.io/s/adoring-snyder-9rkg5





## 测试：判断实例对象的原型链关系

### 代码

https://codesandbox.io/s/cocky-blackwell-trwny



### 关系图



![image-20210409110958018](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20210409110958018.png)



- `prototype`是函数才有的属性, 这个属性叫原型, 保存着共有属性和方法的对象。
- `__proto__`是所有对象都有的属性, 作用是指向对象的原型。
- 【两者关系】谁生产对象，那么对象的`__proto__`指向谁的 prototype





## 私教课知识点

- new 操作的优先级

  - new 与 无括号配合时， . 点符号 优先级 比 new 高；
  - new 与 有括号配合时，先执行 new 操作符，后执行 . 点符号

  ```javascript
  function Foo() {
    getName = function(){
      console.log("1");
    };
    return this;
  }
  Foo.getName = function() {
    console.log("2");
  };
  
  Foo.prototype.getName = function(){
    console.log("3");
  };
  
  var getName = function() {
    console.log("4");
  };
  function getName(){
    console.log("5");
  }
  Foo.getName();
  getName();
  Foo().getName();
  getName();
  new Foo.getName(); // 问题 1
  new Foo().getName(); // 问题 2
  new new Foo().getName(); // 问题 3
  
  /*
  问题 1 解析：
  先找到 Foo.getName 对应函数，然后再执行，相当于
  function FooHelp(){
  	console.log(2)
  }
  new FooHelp()
  结果为 2
  
  问题 2 解析：
  先执行 new Foo(), 【核心】得到 f 实例（为什么不是 window ？）
  然后再执行 f.getName() , 得到 3 
  
  问题 3 解析：
  先执行 new Foo(), 得到 f 实例，此时调用变成
  new f.getName()
  找到 f.getName 对应函数，然后再执行，相当于
  function tesjfkdjfkdsa(){
  	console.log('3')
  }
  new tesjfkdjfkdsa(), 得到 3
  ```

  ```javascript
  function Test1(){
  	return this
  }
  console.log(Test1()) // 问题 1
  console.log(new Test1()) // 问题 2 
  ```

- 题目

  【核心】对象属性或者值查找过程

  ```javascript
  var F = function(){};
  Object.prototype.a = function(){
  	console.log('a prototype')
  };
  Function.prototype.b = function(){
  	console.log('b prototype')
  };
  var f = new F();
  
  /*
  f.a 
  f.__proto__.a  =>  F.prototype.a
  F.prototype.a.__proto__.a => Object.prototype.a
  */
  console.log(f.a()) // 问题 1 能否正常访问
  console.log(F.b()) // 问题 2 能否正常访问
  console.log(f.b()) // 问题 3 能否正常访问
  ```

- 题目

  ```javascript
  function Fn()  
  {  
      this.user = '张三';  
      return {};  
  }
  var a = new Fn;  
  console.log(a.user); // ?
  ```


- this 是运行时对象
- 