 

### 作业

对  IOC 控制翻转 /  DI 依赖注入 理解写一篇文章

### 版本号的理解

3.2.1.RELEASE

- 3 => 主版本
  -  无法保证兼容

- 2 => 次版本
  -  新特性 
  - 保证兼容

- 1 => 增量版本
  -  bug 修复
- RELEASE
  - 发布版本，里程碑版本
  - 可能的值为：RC, Alpha, Beta, GA, SNAPSHOT



### 创建第一个 spring boot 应用



### 对软件工程的错误认识点

- 软件工程，主要完成项目的**可维护与可迭代**，而不是简单的项目实现

  

  



### 编程原则-开闭原则 （OCP）

- **对软件、函数、类的扩展打开，修改封闭** 

-  要实现开闭原则，需要使用面向抽象编程思想（java 利用 interface 与 abstract）
- 实现可维护代码的过程
  - interface
  - 设计模式：工厂模型
  - IOC/DI
  - 面向抽象编程
  - 开闭原则（OCP）
  - 实现可维护代码



###  英雄联盟代码

- java 文件中的 impl 指的是什么？

  

  impl 指的是实现接口的类

  ```
  // 现有一个接口 Person 
  interface Person{
  	public void run(){}
  }
  class StudentImpl implements Person{
  	public void run(){
  		System.print.out('student run');
  	}
  }
  ```

  

  

  ````
  // 定义一个 interface，如果其他类 implement ISkill，那么这个类必须要有 q 这个方法
  interface ISkill {
  	void q(){}
  }
  public class CamierImpl implements ISkill{
  	void q(){
  		System.print.out('Camier q')
  	}
  }
  
  ````

- 单纯的 interface 可以统一方法的调用，但是不能统一对象的实例化 
- 面向对象 实例化对象 调用方法 （完成业务逻辑）
- 只有一段代码中没有 new 的出现，才能保持代码的相对稳定，才能逐步实现 OCP
- 上面的话只是表象，实质是一段代码如果要保持稳定，就不应该负责对象的实例化
- 对象实例化是不可能消除的
- 把对象实例化的过程，转移到其他代码中
-  代码中总会存在不稳定，隔离这些不稳定，保证其他代码是稳定的
- 变化（用户操作或者需求变更）是导致代码不稳定的主要原因



### IOC 的简单理解

- 现有对象 A，其内部需要依赖实例 b

- 最直接的解决方法就是在对象 A 内部通过各种方式（通过直接 new 操作、或者工厂模式）获取实例 b，这种方法违反了 OCP**（常规思维：A 依赖 b，那么 A 需要主动生成 b）**

-  控制翻转的含义

  A 依赖 b，那么容器会把 b 给 A





 

 









 

 







 









