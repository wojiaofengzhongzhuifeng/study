# 函数

## 概述

- 函数定义
- 函数调用
- 函数参数
- 构件函数
- 变量提升与函数提升
- 闭包
- this
- call，apply，bind 函数



## 函数定义

### 方式

- 函数声明

  ```javascript
  function test(){}
  ```

- 函数表达式

  ```javascript
  var test = function(){}
  ```

- 区别
  1. 函数声明必须有函数名称；函数表达式可以是匿名函数，并 把这个函数赋值给变量。
  2. 函数声明会提升；函数表达式不会。

### 使用场景

- 斐波那锲数列（函数定义处调用自身）

  ```javascript
  function fibonacci(number){
  	if(number === 1 || number === 2){
  		return 1
  	}
  	return fibonacci(number -1) + fibonacci(number -2)
  }
  ```

- 模块化

  想实现的通过 var 定义的变量是块级作用域功能

  ```javascript
  var getMoneyObj = function(){
  	var money = 1
  	return {
  		getMoney: function(){
  			console.log(money)
  		}
  	}
  }()
  getMoneyObj.getMoney()
  ```

## 函数的调用方式

- 函数调用

  在**作用域**定义函数，然后调用

  ```javascript
  function test(){
  	console.log(this)
  	console.log(1)
  }
  ```

- 方法函数调用

  在对象内部 value 定义函数

  ```javascript
  let obj = {
    name: 'rjj',
  	getName: function(){
  		console.log(this.name)
  	},
    setName: function(name){
      this.name = name
      return this
    }
  }
  obj.setName('rjjnew').getName()
  ```

- 构造器调用

  ```javascript
  function Person(name){
  	this.name = name
  }
  Person.prototype.getName = function(){
  	console.log(this.name)
  }
  let p1 = new Person('rjj')
  p1.getName()
  ```

- call, apply 函数调用

  指定函数内部 this 的指向

  ```javascript
  function getObjName(){
  	console.log(this.name)
  }
  let obj = {
  	name: 'rjj'
  }
  let obj1 = {
  	name: 'rjj1'
  }
  // obj,obj1 对象都没有打印名字函数，可以这样
  getObjName.call(obj)
  getObjName.call(obj1)
  ```

- 匿名函数调用模式

  声明函数后立即调用

  ```javascript
  let sumNumber = function (number1, number2){
  	return number1 + number2
  }(1,2)
  ```

## 函数参数

- 形参与实参

  形参：函数定义时的变量

  实参：函数调用时的变量

  函数可以不用定义形参，在函数体通过 arguments 对象获取传递的实参进行处理

- 形参与实参的区别

  1. 只能把实参的值传给形参，形参无法修改实参

     ```javascript
     var 实参 = '1'
     function fn(形参){
     	形参 = 2 // 1️⃣
     }
     fn(实参)
     console.log(实参) // 不会因为 1️⃣ 代码变成 2
     ```

     ```javascript
     var 实参 = {name: 1}
     function fn(形参){
     	形参.name = '112332'
     	形参 = {name: 2} // 1️⃣
     }
     fn(实参)
     console.log(实参) // 不会因为 1️⃣ 代码变成 {name: 2}
     ```

- arguments

  如果 arguments[x] 为 undefined 那么形参与arguments 对象不会影响

  ```
  function test(a, b){
  	a = 1111111
  	console.log(arguments[0])
  	arguments[0] = 11111111111
  	console.log(a)
  	console.log('===')
  	b = 222222
  	console.log(arguments[1])
  	arguments[1] = 22222222222
  	console.log(b)
  	
  }
  test(1)
  ```

  应用

  ```
  function sum (){
  	let needSumList = Array.prototype.slice.call(arguments);
  	return needSumList.reduce((pre, next)=>{return pre += next}, 0)
  }
  console.log(sum(1))
  console.log(sum(1,2))
  console.log(sum(1,2,3))
  ```

## 构造函数

- new 做了什么事情

  ```javascript
  function Person(name){
  	this.name = name
  }
  
  let p1 = new Person('rjj')
  console.log(p1.name)
  // 1. 创建 temp 临时变量
  // 2. this = temp
  // 3. 执行 Person 内部代码, 为 temp 赋值
  // 4. 将 temp 作为函数的返回值
  ```

  

## 变量提升与函数提升

- 作用域

  是一个范围，定义了变量（普通变量与函数变量）的定义与使用的作用区间

- 类别

  1. 全局作用域

     在任何位置都可以访问这个变量（控制台也可以访问）

  2. 函数作用域

     函数内部访问

  3. 块级作用域（es6）

     指定代码块+let、const 访问变量

- 变量提升与函数提升的使用，属于落后的东西，先不看了

## 闭包

- 执行上下文

  就是函数执行所需要的环境。

  即调用函数时，在执行栈压入当前函数的执行上下文，函数执行完毕后，从执行栈弹出

  

