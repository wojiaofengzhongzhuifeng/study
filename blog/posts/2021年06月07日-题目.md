## 执行结果

### 原题目

```
function Foo(){
	getName = function(){alert(1)}
	return this
}
Foo.getName = function(){alert(2)}
Foo.prototype.getName = function(){alert(3)}
getName = function(){alert(4)}
function getName(){alert(5)}

// 写出以下结果
Foo.getName();
getName();
Foo().getName();
getName();
Foo.getName();
new Foo().getName();
```

### 分析

1. ✅Foo.getName(); => alert(2)

2. ✅getName(); => alert(4)

   函数声明前置，先是 alert(5)，然后是 alert(4)

3. ✅Foo().getName(); => alert(1)

   运行 Foo() 函数后，覆盖 getName 函数内容。目前是 alert(1)

   Foo() 返回的是 this，实际上返回的就是 window，那么alert(1)

4. ✅getName(); => alert(1)

   由于第三个操作，导致当前的 getName 函数是 alert(1)

5. ✅Foo.getName(); => alert(2)

6. ❌new Foo().getName(); => ~~alert(1)~~  => alert(3);

   ~~new Foo()返回的是 window 对象~~   => 返回的是一个新对象（临时对象）

   window.getName() => alert(1)

   这个返回的是 alert(3)

### 知识点

1. 执行期间，变量提升

2. new 做了什么？

   原来的new 理解有问题，new 操作默认 return this

   ```
   function Person1(){
   	return this
   }
   function Person2(){
   }
   let p1 = new Person1()
   let p2 = new Person2()
   // p1 与 p2 的区别？  => 没有区别
   ```





## 执行结果

### 原题目

```
alert(a)
a()
var a = 3
function a(){
	alert(10)
}
alert(a)
a = 6
a()
```



## Web 性能优化

### 原题目

常见的页面加载优化手段有哪些？

## 跨域

### 原题目

跨域方法有哪些？原理分别是什么？

## 执行结果

### 原题目

```
for(var i=0;i<5;i++){
	setTimeout(function(){
		console.log(new Date(), i)
	}, 1000)
}
console.log(new Date(), i)
```

