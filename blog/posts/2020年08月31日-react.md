## React 为什么要 bind this 

```
let test = {
    a: 1,
    b: function() {
        console.log(this.a)
    }
}
let t1 = test.b
t1()

let t2 = test.b.bind(test)
t2()
```

## React 的 event 对象有什么特殊之处？

- 并不是原生 event 对象
- 所有事件监听都挂载到 document 中
- 通过 event.nativeEvent 获取



## React setState 注意

- **state 是不可被改变的值，即不能改变原 state 的值，只能根据 state 的值生成一个新值**

  ```
  class App extends React.Component{
  	constructor(props) {
  		super(props);
  		this.state = {
  			list: [1],
  			obj: {
  				a: 1,
  				b: 2,
  			}
  		}
  	}
  
  	addItem = () => {
  		this.setState({
  			list: [...this.state.list, Math.random()]
  			obj: {...this.state.obj, a: 2}
  		})
  		
  		/*
  		* 不能这样, 这样修改了 this.state.list 的值
  		* this.setState({
  		*   list: this.state.list.push(Math.random())
  		* })
  		* */
  	}
  	render() {
  		return (
  			<div>
  				{this.state.list.map((number)=>(<div>{number}</div>))}
  				<button onClick={this.addItem}>add item</button>
  			</div>
  		)
  	}
  }
  ```

- setState 同步的情况

  - 当 setState 在 setTimeout 内

  - setState 在自定义 DOM 事件中

    ```
    class App extends React.Component{
    	constructor(props) {
    		super(props);
    		this.state = {
    			number: 1
    		}
    	}
    
    	handleClick = () => {
    		// 1. 当 setState 在 setTimeout 内
    		setTimeout(()=>{
    			this.setState({
    				number: this.state.number + 1
    			})
    			console.log(this.state.number);
    		}, 0)
    	}
    	
    	handleClickBody = () => {
    		this.setState({
    			number: this.state.number + 1
    		})
    		console.log('handleClickBody', this.state.number);
    	}
    	
    	componentDidMount() {
    		// 2. setState 在自定义 DOM 事件中
    		document.addEventListener('click', this.handleClickBody)
    	}
    
    	render() {
    		return (
    			<div>
    				{this.state.number}
    				<button onClick={this.handleClick}>+1</button>
    			</div>
    			
    		)
    	}
    }
    ```

    

- 多次 setState 是否会被合并？

  - 调用 setState 函数，参数是对象会被合并

  - 调用 setState 函数，参数是函数不会被合并

    ```
    class App extends React.Component{
    	constructor(props) {
    		super(props);
    		this.state = {
    			number: 1
    		}
    	}
    
    	handleClick1 = () => {
    		this.setState({
    			number: this.state.number + 1
    		})
    		this.setState({
    			number: this.state.number + 1
    		})
    		this.setState({
    			number: this.state.number + 1
    		})
    	}
    
    	handleClick2 = () => {
    		this.setState((preStates, props)=>{
    			return {
    				number: preStates.number + 1
    			}
    		})
    		this.setState((preStates, props)=>{
    			return {
    				number: preStates.number + 1
    			}
    		})
    		this.setState((preStates, props)=>{
    			return {
    				number: preStates.number + 1
    			}
    		})
    	}
    	
    	render() {
    		return (
    			<div>
    				{this.state.number}
    				<button onClick={this.handleClick1}>+1</button>
    				<button onClick={this.handleClick2}>+3</button>
    			</div>
    			
    		)
    	}
    }
    ```

- 受控 、 非受控组件

- context 的使用

  - 使用 context 初始化需要全局化数据，返回 DataProvider 和 DataComsumer 组件
  - 在组件顶部使用 DataProvider
  - 在需要使用全局化数据的组件使用 DataComsumer

  ```
  import React, { createContext } from 'react'
  
  
  // 1. 使用 context 初始化需要全局化数据
  const ToggleContext = createContext({
  	toggle: true,
  	handleToggle: () => {}
  })
  class ToggleProvider extends React.Component {
  	handleToggle = () => {
  		this.setState({ toggle: !this.state.toggle })
  	}
  	state = {
  		toggle: true,
  		handleToggle: this.handleToggle
  	}
  	render() {
  		return (
  			<ToggleContext.Provider value={this.state}>
  				{this.props.children}
  			</ToggleContext.Provider>
  		)
  	}
  }
  export const ToggleConsumer = ToggleContext.Consumer
  
  
  // 2. 顶部组件使用 provider
  export default function App3() {
  	return (
  		<ToggleProvider>
  			<Switcher />
  		</ToggleProvider>
  	);
  }
  
  const Switcher = () => {
  	return (
  		<div>
  			<Pannel />
  			<Pannel1 />
  		</div>
  	)
  }
  
  // 4. func 方式使用数据
  const Pannel1 = () => {
  	return (
  		<ToggleConsumer>
  			{({ toggle, handleToggle }) => <div onClick={() => handleToggle()}>{ toggle ? '✔' : '❌'}</div>}
  		</ToggleConsumer>
  	)
  }
  // 3. class 方式使用数据
  class Pannel extends React.Component{
  	render() {
  		const {toggle} = this.context
  		console.log(toggle);
  		return (
  			<div>
  				toggle: {toggle === true ? '对' : '错'}
  			</div>
  		)
  	}
  }
  Pannel.contextType = ToggleContext
  
  
  ```

- 异步组件（性能优化）

  ![image-20200905081129376](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20200905081129376.png)

  ```
  import React from 'react'
  
  const LazyButton = React.lazy(()=> import('./Button')) 
  
  class App6 extends React.Component{
  	render() {
  		return (
  			<div>
  				app6
  				<React.Suspense fallback={<div>loading......</div>}>
  					<LazyButton />
  				</React.Suspense>
  			</div>
  		)
  	}
  }
  
  export default App6
  ```

- react 性能优化

  - shouldComponentUpdate（为什么要提供这个 api 让用户手动选择是否渲染）
  - state 使用不可变值
  - 使用 React.PureComponent 与 React.memo （常规组件 + shouldComponentUpdate ）
  - 

  

- 如果父组件 state.data1 变了，即使子组件没有使用 data1，子组件还是会重新渲染!

  父组件state.data1变了，导致父组件 render 执行，所以导致子组件重新执行
此时可以结合 shouldComponentUpdate 手动控制渲染
  
  ![image-20200905092431886](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20200905092431886.png)
  
- 为什么改变 state 的 array 不能使用 push ?
   ![image-20200905095050819](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20200905095050819.png)

  

- 重复逻辑的解决方法

  - 高阶组件
  - render props

- vdom 和 diff

- jsx 的本质是什么

- 合成事件

  ![image-20200905180137913](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20200905180137913.png)

  

- batchUpdate

- 事务机制

- react fiber 如何优化性能

- Vdom 和 diff(另开一个)

- 生命周期
  https://juejin.cn/post/6844903510538977287





## React Hooks

https://mp.weixin.qq.com/s/wcQ3QdrC_4eQkBvsinsrhw

 

