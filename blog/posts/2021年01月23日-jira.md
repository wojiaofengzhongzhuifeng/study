# jira项目观看过程笔记



## 第三章

### ❌public 是静态资源文件，内部的%public% 是什么东西？

？？？

### ❌使用 prettier 在提交之前格式化代码

- 使用 prettier 命令手动格式化代码
- 使用 lint-staged + kusky 在commit 前运行 prettier 命令

### ✅使用json-server 作为 mock 工具

- 将 json-server 通过 `yarn add json-server --dev`安装

- 添加 db.json

- 然后 package.json 添加 script 

  ```diff
    "scripts": {
      "start": "react-scripts start",
      "build": "react-scripts build",
      "test": "react-scripts test",
      "eject": "react-scripts eject",
  +   "mock": "json-server --watch __mock__data__/db.json -p 3001"
    },
  ```

### ✅react组件编写的过程是什么

- 划分组件
- 组件输入
- 组件输出（产生）数据
- 思考组件输出需要触发什么操作，如果触发其他组件操作，需要将该数据提升

### ✅ mock 数据与环境变量的联合使用

- 在 create-react-app 中使用

- setData

  在根目录创建`.env`文件，文件内容如下
  注意变量必须以 `REACT_APP_xxx`开头

  ```
  REACT_APP_API_URL = 'http://localhost:3001'
  REACT_APP_PROD_API_URL = 'http://baidu.com'
  
  ```

- getData

  ```
  const apiUrl = process.env.REACT_APP_API_URL;
  console.log(apiUrl);
  ```

### ✅经验：收集 url query 最佳数据结构

#### 需求

需要根据用户的操作生成如下 url

`http://localhost:3000/projects?projectName=1&handlerId=2`;

那么应该使用一个**对象**去保存数据，而不是使用**几个分散的变量**保存

```diff
+ let filterData = {
+	 projectName: 1,
+	 handlerId: 2,
+ }

- let projectName = 1
- let handlerId = 2
```

为什么呢？因为如果用了下面的数据结构，那么拼接http 的时候，必须手动写 filterKey，这样要经常修改。如果换成对象，直接遍历对象的 key 与 value 生成 filterKey 和 value 就行了

### ✅常见需求

删除一个对象为 falsey 值的 key&value，（不包含 0）

### ❌react组件渲染优化

父组件更新，子组件一定更新，所以对每一个子组件包裹 React.memo(sonComponent)?

### ✅useDebounce使用

3-3-14:08

useEffiect 的回调函数什么时候执行？

重新执行该函数的时候执行



## 第四章

### ✅需要定义什么方面的接口

凡是变量都需要定义 interface.包括函数`输入参数`,`输出参数`, `用户自定义变量`

### 常见的typescript使用案例

#### 如何定义react hooks组件props?

```diff
+ interface Props{
+	 todoList: todo[]
+ }
+const Todo = ({todoList}: Props)=>{
	return (<div></div>)
}
```

#### case1

```
interface Test{
	params: string[]
	fn: (test: Test['params'])=>void
}
```

#### tuple + interface key 的使用

无法在 create-react-app 中使用ts-transformer-keys将 interface key 换成 []

需求： 做信息收集功能，需要收集用户的 username 与 password。

```
interface

优化
const UserInfoType = tuple('username', 'password');
```

### window 挂载 test 变量，但是 ts 提示报错

```typescript
declare global {
    interface Window { API_URL: string; }
}

window.API_URL = "test123321";
```





### 4-5

封装自定义 hooks 的好处

- 将 ui 与逻辑进行分离
- 追加新功能更加简单

使用 hooks 实现useArray，该 hooks 输入原始数组，输出`value` `clear` `removeIndex` `add`

```typescript
interface Person {
  name: 1
}
function useArray<T>(initialArray: T[]): {
  value: T[],
  setValue: (valueList: T[]) => void,
  add: (value: T)=>void,
  clear: () => void,
  removeIndex: (needRemoveIndex: number)=> void
}{
  const [value, setValue] = useState(initialArray);
  return {
    value,
    setValue,
    add: (item: T) => setValue([...value, item]),
    clear: () => setValue([]),
    removeIndex: (index: number) => {
      const copy = [...value];
      copy.splice(index, 1);
      setValue(copy);
    },
  };
}
// get
const {value, setValue, add, clear, removeIndex} = useArray<Person>([])
```



### handleSubmit如何确定event的类型？

把鼠标浮到onChange 事件，idea 有提示

![image-20210130150507057](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20210130150507057.png)

### 登录组件与发送登录接口



### json-server中间件解决非restfulapi

使用 fetch api 发送 username 与 password 时候，为什么不写header： 'Content-Type': 'application/json' ，后端就获取不到数据？

而且添加header： 'Content-Type': 'application/json' 后会多发送一个请求

### 5-2 没有看

### 5-3

完成登录注册接口，并且将 token 保存到 localStorage 中

### 5-4

为什么要把 useAuth 放到 useContext，直接在组件中引入不就 ok 了吗？

这里有一个误区：**如果引用同一个 customhooks，复用逻辑，不共用数据。**那么如何共用数据呢？使用useContext

即组件son与组件sonSon都引用了 useCount，在组件 son 设置 count + 1 ，并不会影响 sonSon 的 count 数据

[点击+1，复用逻辑，不共用数据](https://codesandbox.io/s/compassionate-glitter-2x0vn)

[通过 useContext，复用数据](https://codesandbox.io/s/friendly-joliot-kq5z8?file=/src/App.tsx:504-518)

### ✅5-5

使用 useAuth 判断是否登录状态，根据这个状态显示「未登录组件」与「登录组件」

### 5-6 5-7

使用 fetch api 封装 http ，完成登录注册功能

9:17

### 5-8 常见 utility type 的使用

type的使用1

```diff
- let youFavoriteNumber: string | number = 1
- let myFavoriteNumber: string | number = 2

+ type favoriteNumber = string | number;
+ let youFavoriteNumber: favoriteNumber = 1;
+ let myFavoriteNumber: favoriteNumber = 2;
```

utility type 1：Parameters



```typescript
const http = (
  test1: number,
  test2: string
)=>{
  console.log(1)
}
type test = Parameters<typeof http>
let t1: test = [1, '3']
```

utility type 2：partial

使用场景：选择原接口的 0 到 n 个属性

```typescript
interface UserInfo{
  username: string
  password: string
}
let person: Partial<UserInfo> = {username: '1'}
```

utility type 2：omit

使用场景： 去除原接口的指定属性 

```typescript
type UserInfo = {
  username: string
  password: string
  age: number
}
type test = Omit<UserInfo, 'username' | 'age'>
let t1: test = {password: '1'} // ✅
let t2: test = {age: 1} // ❌
```

### 第五章小结

完成登录注册功能



