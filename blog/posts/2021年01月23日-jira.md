# jira项目观看过程笔记



## 第三章

### ❌public 是静态资源文件，内部的%public% 是什么东西？

？？？

### ❌使用 prettier 在提交之前格式化代码

- 使用 prettier 命令手动格式化代码
- 使用 lint-staged + kusky 在commit 前运行 prettier 命令

### ✅使用json-server 作为 mock 工具

- 将 json-server 通过 `yarn add json-server --dev`安装

- 添加 db.json

- 然后 package.json 添加 script 

  ```diff
    "scripts": {
      "start": "react-scripts start",
      "build": "react-scripts build",
      "test": "react-scripts test",
      "eject": "react-scripts eject",
  +   "mock": "json-server --watch __mock__data__/db.json -p 3001"
    },
  ```

### ✅react组件编写的过程是什么

- 划分组件
- 组件输入
- 组件输出（产生）数据
- 思考组件输出需要触发什么操作，如果触发其他组件操作，需要将该数据提升

### ✅ mock 数据与环境变量的联合使用

- 在 create-react-app 中使用

- setData

  在根目录创建`.env`文件，文件内容如下
  注意变量必须以 `REACT_APP_xxx`开头

  ```
  REACT_APP_API_URL = 'http://localhost:3001'
  REACT_APP_PROD_API_URL = 'http://baidu.com'
  
  ```

- getData

  ```
  const apiUrl = process.env.REACT_APP_API_URL;
  console.log(apiUrl);
  ```

### ✅经验：收集 url query 最佳数据结构

#### 需求

需要根据用户的操作生成如下 url

`http://localhost:3000/projects?projectName=1&handlerId=2`;

那么应该使用一个**对象**去保存数据，而不是使用**几个分散的变量**保存

```diff
+ let filterData = {
+	 projectName: 1,
+	 handlerId: 2,
+ }

- let projectName = 1
- let handlerId = 2
```

为什么呢？因为如果用了下面的数据结构，那么拼接http 的时候，必须手动写 filterKey，这样要经常修改。如果换成对象，直接遍历对象的 key 与 value 生成 filterKey 和 value 就行了

### ✅常见需求

删除一个对象为 falsey 值的 key&value，（不包含 0）

### ❌react组件渲染优化

父组件更新，子组件一定更新，所以对每一个子组件包裹 React.memo(sonComponent)?

### ❌useDebounce使用

3-3-14:08

useEffiect 的回调函数什么时候执行？

重新执行该函数的时候执行





 ## 第四章

### 把js换成ts

#### 需要定义什么方面的接口

- 接口返回的数据类型
- 组件的 props
- 组件 state 的泛型

### 常见的typescript使用案例

#### 如何定义react hooks组件props?

```diff
+ interface Props{
+	 todoList: todo[]
+ }
+const Todo = ({todoList}: Props)=>{
	return (<div></div>)
}
```

#### case1

```
interface Test{
	params: string[]
	fn: (test: Test['params'])=>void
}
```

#### 泛型

```

```



### 4-5

封装自定义 hooks 的好处

- 将 ui 与逻辑进行分离
- 追加新功能更加简单

使用 hooks 实现useArray，该 hooks 输入原始数组，输出`value` `clear` `removeIndex` `add`

```typescript
interface Person {
  name: 1
}
// set
const useArray = <T>(initialArray: T[]) => {
  const [value, setValue] = useState(initialArray);
  return {
    value,
    setValue,
    add: (item: T) => setValue([...value, item]),
    clear: () => setValue([]),
    removeIndex: (index: number) => {
      const copy = [...value];
      copy.splice(index, 1);
      setValue(copy);
    },
  };
};

// get
const {value, setValue, add, clear, removeIndex} = useArray<Person>([])
```



### handleSubmit如何确定event的类型？

如何定义事件回调函数 event 的类型？

### 登录组件与发送登录接口



### json-server中间件解决非restfulapi

5-1-17：49

### 5-2 没有看



