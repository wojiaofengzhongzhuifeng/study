# next 渲染方式



## 解决的问题

**根据实际情况选择最优的渲染方式**

渲染什么？

渲染用户视图，而用户视图是由 HTML 决定的，所以问题变成：根据实际情况选择最优的 HTML 生成方式



## 根据实际需求，渲染方式的优化过程

- 用户想看文章内容
  文章内容的特点是文章内容不会变（假定）

  服务器直接返回如下的 HTML 即可

  ```html
  <!doctype html>
  <body>
    <h2>美好的一天</h2>
    <p>内容内容内容内容内容</p>
  </body>
  </html>
  ```

  这种方式叫**静态渲染**

- 用户想看每日文章列表

  每日文章列表的特点是「每天的数据都不一致 + 每个用户请求内容都是一致的」，所以服务器返回如下 HTML

  ```html
  <!DOCTYPE html>
  <html>
  <body>
  <div id="__next">
    <ul class="container"><a href="/blogs/第一篇文章">第一篇文章</a></ul>
  </div>
  <script id="__NEXT_DATA__" type="application/json">{
    "props": {
      "pageProps": {
        "responseData": {
          "code": 0,
          "message": "成功",
          "data": [
            {
              "title": "第一篇文章",
              "id": 0.9721849214661944
            }
          ]
        },
        "test": 12321123321123320
      },
      "__N_SSG": true
    },
    "page": "/posts",
    "query": {},
    "buildId": "ja1khOUfCR3o27RKMY0tp",
    "nextExport": false,
    "isFallback": false,
    "gsp": true
  }</script>
  </body>
  </html>
  ```

  这个 HTML 由「普通的标签 + 每日博客列表数据」组成，不同用户请求每日博客时，会直接拿到上面的 HTML 文件，浏览器拿到这个 HTML 渲染即可 

  这种方式叫**动态内容静态化**

- 用户想查看订阅的博客列表

  订阅的博客列表的特点是「根据用户的订阅数据，返回不同的博客列表」，也就说响应数据（简化为 HTML ）是根据请求数据生成，所以服务器返回如下 HTML

  ```html
  <!DOCTYPE html>
  <html>
  <body>
  <div id="__next">
    <ul class="container"><a href="/blogs/第一篇文章">饶家俊订阅的第一篇文章</a></ul>
  </div>
  <script id="__NEXT_DATA__" type="application/json">{
    "props": {
      "pageProps": {
        "responseData": {
          "code": 0,
          "message": "成功",
          "data": [
            {
              "title": "饶家俊订阅的第一篇文章",
              "id": 0.9721849214661944
            }
          ]
        },
        "test": 12321123321123320
      },
      "__N_SSG": true
    },
    "page": "/posts",
    "query": {},
    "buildId": "ja1khOUfCR3o27RKMY0tp",
    "nextExport": false,
    "isFallback": false,
    "gsp": true
  }</script>
  </body>
  </html>
  ```

  这种方式叫**用户相关动态内容静态化**

- 上述所有渲染情况，都可以用客户端进行方式实现，返回的 HTML 如下

  ```html
  <!doctype html>
  <body>
  <div id="app"></div>
  <script>
    let h1 = document.createElement('h1')
    h1.innerText = '文章'
    app.appendChild(h1)
  </script>
  </body>
  </html>
  ```

  这种方式叫**客户端渲染**

  这样的方式存在的问题有

  - 无法 SEO
  - 产生白屏



## 对上面内容的疑问

- 「每日文章列表」与「订阅的博客列表」返回的 HTML 看起来都一样，他们区别在哪里？

  - 不同用户返回的订阅数据不同的

    用户 1 返回的「每日文章列表」是 1

    用户 1 返回的「订阅的博客列表」 2

    用户 2 返回的「每日文章列表」是 1

    用户 2 返回的「订阅的博客列表」 3

  - 数据构建时机不同
    ![image-20200804102523608](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20200804102523608.png)

    红框的数据，如果是 build 阶段（从源代码编译成生产环境代码）生成的，不管用户请求多少次，都返回上面的 HTML 文件，那么是动态页面静态化渲染

    如果是在用户请求过程中，用户请求多少次，就在服务器生成多少个 HTML 再返回给用户浏览器渲染，那么就是动态页面静态化渲染

  

## 给上述的渲染过程起一个专业词汇

- 静态渲染 => 无
- 动态内容静态化 => SSG
- 用户信息动态内容静态化 => SSR
- 客户端渲染 => BSR



其中 SSG 和 SSR 属于服务端渲染





## 在 next 如何实现服务端渲染

- SSG = getStaticProps + getStaticPaths
- SSR = getServerSideProps



## 如何选择渲染方式（思考模型）

- 动态内容与「客户端」相关的话只能用 BSR 渲染
- 动态内容与「请求 request or 用户信息」相关的话只能用 SSR 或者 BSR 渲染



- 优先渲染

  静态渲染  =①> SSG =②> SSR =③> BSR

  ①的情况：有动态数据

  ②的情况：有「请求 request or 用户信息」

  ③的情况：所有情况都可以使用

## 理解服务端渲染的 demo需求

- 需求 1：包含文章列表
- 需求 2：点击文章列表，展示文章详情

- 不懂的点
  ![image-20200804212430236](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20200804212430236.png)







