# 继承

## 实现继承方法

### 原型链继承

#### 思路

​	子构造函数（Student）的 prototype 指向父构造函数（Person）的实例

#### 代码

​	https://jsbin.com/leforiponu/1/edit?js,console,output

#### 🌟⭐图示继承重点

​	代码		![B4F775AE-97E3-42B9-9F52-C008735687E2](/var/folders/rn/f9wc9bns64b84fbj46knxl4w0000gn/T/ro.nextwave.Snappy/ro.nextwave.Snappy/B4F775AE-97E3-42B9-9F52-C008735687E2.png)

对应的图示是

![](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/image-host/master/img/20190516142623.png)

#### 缺点

 1. 属性是引用类型，实例之间相互影响

    如果父构造函数类型（Person）的实例属性是引用类型（body）， 那么每个子构造函数（Student）的实例对象A，实例对象B的实例属性（body）都会互相影响。

2. 无法传递参数

   创建子构造函数（Student）的实例，不能向父构造函数（Person）中传递参数（name）。



### 借用构造函数

#### 思路

​	调用父构造函数，继承父构造的实例属性

#### 代码

​	https://jsbin.com/nicobusava/1/edit

#### 缺点

	1. 只能继承实例属性，无法继承公共方法



### 组合继承

#### 思路

​	使用原型链，继承父构造函数的公共属性；借用构造函数，继承父构造函数的实例属性

#### 代码

​	https://jsbin.com/miripucafa/1/edit

#### 缺点

1. 调用两次父构造函数

### 原型继承

🚧

### 寄生式继承

🚧

### 寄生组合式继承

🚧

### ES5 完美的继承

#### 思路

​	以组合继承为基础，更好的实现继承

代码

​	https://jsbin.com/febasodaxi/1/edit?js,console,output

## new 做了什么？

1. 生成临时对象 tempObj
2. 令 `tempObj.__proto__ === Test.prototype`
3. 执行 Test 函数，并且内部的 this 指向 tempObj
4. Test 函数返回 tempObj

[例子](https://jsbin.com/hakiwomuno/1/edit?js,console,output)



### 问题

1. 组合继承/完美继承时， 为什么不直接Student.prototype = Person.prototype，而是要Student.prototype = new Person()？

   那么 Student.prototype.study 的 study 方法会在 Person，而不是 Student 中

   https://jsbin.com/kugogogugo/1/edit?js,console,output











