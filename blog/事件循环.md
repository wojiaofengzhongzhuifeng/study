# Event Loop

## 笔记

1. js 是单线程

2. 当 js 执行一个异步任务(ajax 或者 setTimeout)， 发送一个消息给 c++ ，通知c++轮询确认异步任务是否完成，如果完成，那么 c++发送一个事件给 js，js 能拿到异步任务结果

3. 代码

   ```
   setTimeout(()=>{
   	console.log(1)
   }, 200)
   ```

   Event Loop 可以保证，200ms 后，执行 console.log(1)

4. Event Loop === 事件循环 === 状态变化的阶段

   重要的阶段分别是

   timers

   poll

   check

   ![](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/image-host/master/img/20190514190915.png)

5. 执行 js === 将 fn 放到队列中

6. 开启 eventloop === 执行事件循环，执行队列任务 === 从 poll 阶段开始

7. "执行 js" 与 "开启 eventloop"两者谁先执行，不能确定。

8. 如果想确定谁先执行，可以把代码放到一个 settimeout 中，这样可以保证 "开启 eventloop"先执行

9. progress.next 不属于 eventloop 的一部分

10. nexttick === 当前阶段执行完毕后立即执行





## nodejs

知道三个 api

1. setTimeout(fn1) 
2. setImmediate(fn2)
3. progress.nextTick(fn3)

知道三个运行阶段(有顺序)

1. timer 
2. poll
3. checkout

知道 api 的回调函数分别放到什么运行阶段

1. fn1 放到 timer 队列 (宏任务)
2. fn2 放到 checkou 队列中 (宏任务)
3. fn3 等待该阶段执行完毕后，立即执行 fn3 (微任务)

知道如何分析

1. 浏览代码，将回调函数分别放到相应的队列中
2. 从 poll 开始执行

代码

```javascript
setTimeout(()=>{
  setImmediate(()=>{
    console.log("setImmediate 1")
    setTimeout(()=>{
      console.log("settimeout 1")
    }, 0)
  })

  setTimeout(()=>{
    console.log('settimeout 2');
    setImmediate(()=>{
      console.log('setImmediate 2');
    })
  }, 0)
}, 1000)
```

## 前端

知道 3 个 api

1. setTimeout(fn1)
2. promise.then(fn2)
3. async 转化为 promise

知道任务类型

1. 宏任务(一会做)
2. 微任务 (马上做)

知道 api 属于什么任务类型

1. Fn1 宏任务
2. Fn2 微任务

代码

```
async function async1(){
	console.log(1)
	await async2()
	console.log(2)
}

async function async2(){
	console.log(3)
}

async1()

new Promise(function(resolve){
	console.log(4)
	resolve()
}).then(()=>{
	console.log(5)
})
```

