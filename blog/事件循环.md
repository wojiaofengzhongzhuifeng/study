# Event Loop



## 总结

1. 只有 progress.nextTick  + promise.then() 是微任务，其他都是宏任务



## nodejs

### 执行原则

1. 有三个重要阶段

   ![](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/image-host/master/img/20190514190915.png)

2. 一般来说，从 poll 开始执行

### 异步任务分类

1. setTimeout(fn1)  => 放入 timer 队列中 => 放到宏任务
2. setImmediate(fn2) => 放入 checkout 队列中 => 放到宏任务
3. progress.nextTick(fn3) => 等待该阶段执行完毕，立刻执行，不属于任何队列 => 放到微任务

### 示例代码

```javascript
setTimeout(()=>{
  setImmediate(()=>{
    console.log("setImmediate 1")
    setTimeout(()=>{
      console.log("settimeout 1")
    }, 0)
  })

  setTimeout(()=>{
    console.log('settimeout 2');
    setImmediate(()=>{
      console.log('setImmediate 2');
    })
  }, 0)
}, 1000)
```

## 前端

### 执行原则

1. 执行完同步代码，才执行异步代码
2. 执行完微任务，再执行宏任务



### 异步任务分类

1. setTimeout(fn1) => fn1 是宏任务(等一会)
2. promise.then(fn2) => fn2 是微任务(马上)
3. async 转化为 promise

### 示例代码

#### 没有 async

重点：

1. 执行完微任务 console.log("d") 后，立即向微任务队列中添加微任务 console.log("e")，紧接着执行微任务 console.log("e")。

   并不是先执行宏任务 console.log("b")

```javascript
console.log('a');
setTimeout(() => {
    console.log('b');
}, 0);
console.log('c');
Promise.resolve().then(() => {
    console.log('d');
})
.then(() => {
    console.log('e');
});
console.log('f');

```



#### 有 async

重点：

1. A 的代码这样转化

   转化前

   ```javascript
   // A
   await async2()
   console.log(2)
   setTimeout(()=>{
   	console.log(6)
   }, 0)
   ```

   转化后

   ```javascript
   async2().then(()=>{
     console.log(2)
     setTimeout(()=>{
       console.log(6)
     }, 0)
   })
   ```
   
   ```javascript
   async function async1(){
   	console.log(1)
     // A
   	await async2()
   	console.log(2)
   	setTimeout(()=>{
   		console.log(6)
   	}, 0)
   }
   
   async function async2(){
   	console.log(3)
   }
   
   async1()
   
   new Promise(function(resolve){
   	console.log(4)
   	resolve()
   }).then(()=>{
   	console.log(5)
   })
   ```
   
   

