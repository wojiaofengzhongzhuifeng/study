## 关键词

事件循环、线程、进程、宏任务、微任务、任务队列、同步/异步、阻塞/非阻塞、事件循环event loop、call stack 调用栈、queue 队列



# 知识点

- js 是单线程的，为什么能执行异步任务？

  - 浏览器多个进程；其中渲染进程中包含 js 引擎线程、定时器线程、HTTP 请求线程
  - js 在 js 引擎线程执行
  - js 遇到异步任务（setTimeout，http 请求），会将异步任务放入其他线程（定时器线程，HTTP 请求线程），继续执行同步任务，等到异步任务执行完毕后，通过回调的方式将异步结果返回给 js 引擎线程

- 宏任务、微任务的比较

  - 宏任务需要其他线程支持；微任务不需要其他线程支持

- **宏任务（Macrotask）**：`script`（整体代码）、`setTimeout`、`setInterval`、`XMLHttpRequest.prototype.onload`、`I/O`、UI 渲染，点击事件

- **微任务（Microtask）**：`Promise`、`MutationObserver`

- Event Loop 核心流程
  1. 主线程(调用栈)之外，存在一个 **任务队列**(先放的函数，先执行)
  2. 走主线程的时候，如果碰到异步任务，那么就在 「任务队列」 中放置这个异步任务。注意区分宏微任务。
  3. 等待主线程运行完毕后，查看宏微任务队列是否存在任务，先运行完所有微任务，**才(核心！！！)**运行宏任务。

- 常见的代码执行顺序

  - `a().then(fn1)` 

    同步执行 a 函数，并且将 fn1 放入到微任务队列，先不执行 fn1

  - `async1()` vs `await async1()`

    - 共同点1：`async1`函数内部是同步执行

    - 不同点1：`async1()`表示后面的代码是**依然**同步执行

    - 不同点2：`await async1()`表示先执行 async1 代码，然后再将后面的代码放到微任务中

    - 示例代码

      ```javascript
      async function async1(){
      	console.log(1) 
      	await async2()
      	console.log(2)
      }
      async function async2(){
      	console.log(3) 
      }
      async1()
      console.log(4)
      // 结果 1 => 3 => 4 => 2
      ```

      ```javascript
      async function async1(){
      	console.log(1)
      	await async2()
      	console.log(2)
      }
      async function async2(){
      	console.log(3)
      }
      await async1()
      console.log(4)
      // 结果 1 => 3 => 2 => 4
      ```
    
   - 连续调用 then 

     【新知识】：调用完 callback3 后，发现有 callback4 ，则把 callback 4 放入微任务最后一个

     ```javascript
     Promise.resolve()
       .then(function callback3() {
         console.log("promise1");
       })
       .then(function callback4() {
         console.log("promise2");
       });
     Promise.resolve().then(function callback5() {
       console.log("promise3");
     });
     // 结果：promise1 => promise3 => promise2
     // 微任务队列变化
     // callback3 => callback5
     // ~callback3~ => callback5 => callback4
     ```

     


## 题目


- setInterval

  【结论】setInterval 不影响同步结果
  
  ```javascript
  var flag = false
  setInterval(function(){
    flag = true;
  }, 1000)
  while(flag){
     console.log('running')//
  }
  // 结果
  // 不打印任何值
  // 【结论】setInterval 不影响同步结果？
  ```
- setTimeout 

  【结论】setTimeout 不影响同步结果
  
  ```javascript
  var flag = true
  setTimeout(function(){
      flag = false
  }, 1000)
  while(flag){
     console.log('running')
  }
  // 结果 一直打印 running 
  ```
  
- async 的执行顺序 纯微任务执行顺序

  ```javascript
  async function promise1() {
    console.log('promise 1-1')
    await promise2(); // 【新知识】promise2 函数内部是同步执行；后面的所有内容作为 then 的内容执行
    console.log('promise 1-2')
    await promise3();
    console.log('promise 1-3')
  }
  async function promise2() {
    console.log('promise2');
  }
  async function promise3() {
    console.log('promise3');
  }
  promise1(); // 【新知识】如果 async 函数在调用的时候没有 await ，那么后面的内容是同步的
  new Promise((resolve) => {
    console.log('promise4');
    resolve()
  }).then(() => {
    console.log('100');
  })
  
  // 结果
  // promise 1-1 => promise2 => promise4 => promise 1-2 => promise3 => 100 => promise 1-3
  ```

- 宏任务内生成微任务；微任务内生成宏任务

  ```javascript
  setTimeout(function callback5() {
    console.log('timeout1');
    Promise.resolve().then(function callback6() {
      console.log('tttttt')
    })
  }, 0);
  
  console.log('start');
  
  Promise.resolve().then(function callback1() {
    console.log('promise1');
  
    Promise.resolve().then(function callback2() {
      console.log('promise2');
      setTimeout(function callback8() {
        console.log('ppppp')
        Promise.resolve().then(function callback7() {
          console.log('aaaa')
        })
      });
    });
  
    setTimeout(function callback3() {
      console.log('fffff')
      Promise.resolve().then(function callback4() {
        console.log('promise3');
      });
  
      console.log('timeout2')
    }, 0);
  
  });
  
  console.log('done');
  ```

- 连续调用 then 

  ```javascript
  console.log("script start");
  
  setTimeout(function callback1() {
    console.log("setTimeout---0");
  }, 0);
  
  setTimeout(function callback2() {
    console.log("setTimeout---200");
    setTimeout(function callback11() {
      console.log("inner-setTimeout---0");
    });
    Promise.resolve().then(function callback12() {
      console.log("promise5");
    });
  }, 200);
  
  Promise.resolve()
    .then(function callback3() {
      console.log("promise1");
    })
    .then(function callback4() {
      console.log("promise2");【新知识点】：搜索 「连续调用 then」
    });
  Promise.resolve().then(function callback5() {
    console.log("promise3");
  });
  console.log("script end");
  // 结果： script start => script end => promise1 => promise3=> promise2 => setTimeout---0 => setTimeout---200 => promise5 => inner-setTimeout---0
  // 微任务 ~callback3~ => ~callback5~ => ~callback4~ => ~callback12~
  // 宏任务 ~callback1~ => ~callback2~ => ~callback11~
  ```

- 题目 3

  ```
  setTimeout(function callback1(){
  	console.log(1)
  }, 0)
  console.log(2)
  const promise2 = new Promise((resolve)=>{
   console.log(3)
   resolve(4)
  })
  console.log(6)
  promise2.then(function callback2(){
  	console.log(5)
  })
  ```
  
- 题目 4
  
  ```
  const p1 = function(){
  return new Promise((resolve)=>{
  // 这里正常执行，执行 2️⃣ 代码
  // 如果这里抛出错误，执行 3️⃣ 代码
  resolve(100)
  })
  }
  p1().then(()=>{
  // 2️⃣
  console.log(111)
  })
  
  const p2 = function(){
  return new Promise((resolve)=>{
  throw new Error('error')
  resolve(100)
  })
  }
  p2().then(()=>{
  console.log('4343')
  }).catch(()=>{
  // 3️⃣
  console.log('33')
  })
  ```
  
- 题目 5

  ```
  Promise.resolve().then(()=>{
  	console.log(1)
  }).catch(()=>{
  	console.log(2)
  }).then(()=>{
  	console.log(3)
  })
  ```

- 题目 6

  ```
  for(var i=0;i<5;i++){
  	setTimeout(function(){
  		console.log(new Date(), i)
  	}, 1000)
  }
  console.log(new Date(), i)
  ```

- 题目 7

  ```
  async function async1(){
  	console.log(1);
  	await async2();
  	console.log(2);
  }
  async function async2(){
  	console.log(3)
  }
  async1();
  new Promise(function callback1(resolve){
  	console.log(4)
  	resolve()
  }).then(function callback2(){
  	console.log(5 )
  })
  ```

- 题目 8 （题目 7 变种）

  ```
  async function async1(){
  	console.log('start')
  	await async2()
  	console.log('end')
  }
  async function async2(){
  	console.log('async2')
  }
  console.log('script start ')
  setTimeout(function callback1(){
  	console.log('setTimeout')
  }, 0)
  async1()
  new Promise((resolve)=>{
  	console.log('promise1')
  	resolve()
  }).then(function callback2(){
  	console.log('promise2')
  })
  console.log('scrpit end')
  ```

- 题目 9 （题目 8 变种）

  ```
  async function async1(){
  	console.log('start')
  	await async2()
  	console.log('end')
  }
  async function async2(){
  	console.log('async2')
  }
  console.log('script start ')
  setTimeout(function callback1(){
  	console.log('setTimeout')
  }, 0)
  await async1() // 添加 await
  new Promise((resolve)=>{
  	console.log('promise1')
  	resolve()
  }).then(()=>{
  	console.log('promise2')
  })
  console.log('scrpit end')
  ```

  

## 注意点



### event loop nodejs 的阶段

1. timers
2. poll
3. check

setTimeout => timer 阶段

setImm => check 阶段

nextTick=> 当前阶段的下个阶段



### event loop 浏览器 阶段

1. 宏任务（一会）
2. 微任务（马上）

setTimeout => 宏任务

promise => 微任务

