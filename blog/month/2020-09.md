## 2020.09.07

- 为什么要分为 dev 分支和 test 分支？即为什么要把 开发过程和解决 bug 的过程区分开？

  假设你已经开发完了 1，2，3，4，5 个功能，然后在解决 bug 的时候，产品临时加入 6 功能，这时候测试相当于要重新测 1，2，3，4，5，6（因为你有可能在实现 6 的时候把 1，2，3，4，5bug 回归）





```
	        if(e.target.tagName === 'A'){
            // 对文档简介做特殊处理
		        if(e.target.innerText === '文档简介'){
			        specialExecScroll('1.1')
		        } else {
			        scrollToMenuView(searchLiUrl);
		        }
	        }
```

-

```

```

-

```
    function scrollToMenuView(view){
	    let htmlString = getUserLookForHTMLString()


	    let htmlStringFromAHref = view ? view.split('/').filter((string)=>{
		    return string.includes('.html');
	    })[0].split('.')[0] + '.html' : undefined

	    if(htmlStringFromAHref){
	      execScroll(htmlStringFromAHref)
      } else {
	      execScroll(htmlString)
	    }
    }
```

-

```
    function execScroll(string){
	    let wantedScrollLi = $('.summary').find(`li[data-path*='${string}']`)[0]
	    if(wantedScrollLi){
	      let wantedScrollLiDataLevel = wantedScrollLi.getAttribute('data-level'); // 1.16.2.2.1
		    let allDataLevel = createDataLevel(wantedScrollLiDataLevel)
		    setTimeout(()=>{
	        allDataLevel.forEach((dataLevel) => {
		        let tempNode = document.querySelector(`[data-level="${dataLevel}"]`)
		        tempNode && addExpandedClassName(tempNode, 'expanded')
	        })
	        wantedScrollLi.classList.add('active')
          
	        $('.summary').find(`li[data-path*='${string}']`)[0].scrollIntoView()
          
          if(!checkScrollToButton('.book-summary')){
	          $('.book-summary').scrollTop($('.book-summary').scrollTop() - 50)

          }

		    }, 500)
      }
    }
    
    function specialExecScroll(dataLevel){
	    setTimeout(()=>{
		    $('.summary').find(`li[data-level='${dataLevel}']`)[0].scrollIntoView()
		    $('.book-summary').scrollTop($('.book-summary').scrollTop() - 50)
	    }, 500)
    }
    
    function checkScrollToButton(className){
    	return $(className)[0].scrollHeight - $(className)[0].scrollTop === $(className)[0].clientHeight
    }
```







## 2020.09.05

- react render 函数，只会渲染数字 + 字符串 + array，比如下面的代码就不会渲染 true

  ![image-20200905074914798](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20200905074914798.png)

  

  

- context 的使用

  

- 异步加载组件









## 2020.09.04

- bug 原因：点击 a 标签的时候，滚动条自动返回到最顶部



## 2020.09.03

- 正在完成需求 1，发现有 bug，需要返回到需求 1 之前的未更改过的代码

  ```
  git stash  // 恢复到未更改的代码
  git stash pop // 恢复到正在完成需求 1 代码
  ```

- 状态管理的常见需求，以及如何使用 mobx 进行管理(存疑)

  假设有个大组件，大组件内部有两个小组件，那么可以添加一个 mobx store 用于存储大组件内部所有数据。

  在小组件内部，不要在 state 存储数据，而是从 store 拿数据，然后使用就行了。

  如果在小组件 1 修改了 store 的值a，并且在组件 2 使用 a 值，那么组件 2 会在所有使用 a 值的渲染函数重新执行



## 2020.09.02









## 2020.09.01

- 数据类型还可以是什么？如何录入？
  ![image-20200901143550987](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20200901143550987.png)

- 如何录入文档数据？

  ![image-20200901143622980](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20200901143622980.png)

- 如何录入同级业务构件
  ![image-20200901143649279](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20200901143649279.png)

- 导出报告未实现

- 数据链数据未展示

- 目标：创建一个 CustomTable 组件，

