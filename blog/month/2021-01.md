

## 2020.01.05

- 使用 TDD 思想实现代码深克隆

- 递归 => 尾递归

- 递归例子

  - 输入 5， 输出 5 * 4 * 3 * 2 * 1 的结果

    ```javascript
    function xxx(number){
      if(number === 1) return 1;
      if(number === 0) return 0;
    
      return number * xxx(number - 1);
    }
    
    console.log(xxx(0));
    console.log(xxx(1));
    console.log(xxx(2));
    console.log(xxx(3));
    console.log(xxx(4));
    console.log(xxx(5));
    ```

  - 输入 x，n。输出 x 的 n 次方。

    ```javascript
    // pow(3, 4) === 3*3*3*3
    function pow(x, n){
      if(n === 1) return x;
    
      return x * pow(x, n - 1)
    }
    console.log(pow(3, 4));
    ```

  - 数组扁平

    输入[[1,2,3], [4,[5]], [6, [7, [8]]]，输出[1,2,3,4,5,6,7,8]

    ```javascript
    function fn(arr){
      let arr1 = []
      arr.forEach((val)=>{
        if(val instanceof Array){
          arr1 = arr1.concat(fn(val))
        }else{
          arr1.push(val)
        }
      })
      return arr1
    }
    console.log(fn([[1,2,3], [4,[5]], [6, [7, [8]]]));
    ```

  - 跳台阶

    > 一只青蛙可以一次跳 1 级台阶或者一次跳 2 级台阶，例如：
    >
    > 跳上第 1 级台阶只有一种跳法：直接跳 1 级即可。
    >
    >  跳上第 2 级台阶有两种跳法：每次跳 1 级，跳两次；或者一次跳 2 级。 
    >
    > 问要跳上第 n 级台阶有多少种跳法？

    ```
    function jump(stageNumber){
    	if(stageNumber === 1)return 1;
    	if(stageNumber === 2)return 2;
    	return jump(stageNumber - 1) + jump(stageNumber - 2);
    }
    ```

    

- url 获取参数

## 2020.01.04

- https://www.zhihu.com/question/28586791/answer/41779918
- https://www.zhihu.com/question/28586791/answer/774605294
- 幂等性 === 调用一次与多次对数据状态一致
- get，post 区别
  - 参数位置
    - 编码 ASCII 
    - 缓存
  - 幂等

- put / patch

  put 全局更新

  patch 局部更新

- URI 与 URL 区别

  - 都是用于标识资源位置的方法

  - URI = Uniform Resource Identifier 统一资源**标志符**

  - URL = Uniform Resource Locator 统一资源**定位符**
  - URN = Uniform Resource Name 统一资源**名称**

- 状态码

  - 3xx：重定向状态
  - 301：永久重定向
  - 302：临时重定向
  - 304：协商缓存

- 前端路由

  - hash 路由

    - 表现形式

       `/#/todoList`

    - 修改路由

      通过 `location.href = location.href + Math.random()` 修改路由

    - 监听路由

      `window.addEventListener('hashchange', (e)=>{console.log(e)})`

  - history 路由

    - 表现形式

      `/todoList`

    - 修改路由

      window.history 共有 5 个 api 可以修改路由

    - 监听路由

      `window.addEventListener('popstate', (e)=>{ console.log(e)})`

      但是 pushState 与 replaceState 必须通过 eventBus 的方式进行监听

- 浏览器渲染步骤
  - DOM => CSSOM => Render Tree => Layout => Painting
  - 解析 HTML，生成 「DOM 树」 
  - 解析 CSS，生成 「CSSOM 树」
  - 将 DOM 与 CSSOM 树进行结合，生成「渲染树 Render Tree」
  - 「Layout 布局」：根据渲染树，进行操作，得到节点的「几何信息（位置，大小）」
  - 「Painting(重绘)」：使用渲染树 + 几何信息进行渲染

- 回流与重绘

  - 回流

    因Render Tree 元素的属性（位置、大小）发生变化，浏览器需要重新渲染页面的过程

  - 重绘

    因Render Tree 元素的属性（字体）发生变化，流量器需要将新样式赋予给元素并重新绘制它

  - 触发回流的操作

    - 进行 DOM 操作
    - 元素尺寸发生变化
    - 窗口尺寸发生变化
    - css 伪类激活
    - 获取布局信息的操作

- ❌js实现函数重载，使用闭包实现的，不是很理解

  ```javascript
    var people = {
      values: ['Dean Edwards', 'Sam Stephenson', 'Alex Russell', 'Dean Tom']
    };
  
  
    function addMethod (object, name, fn) {
      // 把前一次添加的方法存在一个临时变量old中
      var oldFn = object[name];
  
      // 重写object[name]方法
      object[name] = function () {
        if (fn.length === arguments.length) {
          // 如果调用object[name]方法时，如果实参和形参个数一致，则直接调用
          return fn.apply(this, arguments);
        } else if (typeof oldFn === 'function') {
          // 如果实参形参不一致，判断old是否是函数，如果是，就调用old
          return oldFn.apply(this, arguments);
        }
      };
    }
  
    addMethod(people, 'find', function() {
      return this.values;
    });
  
    addMethod(people, 'find', function(firstName) {
      return this.values.filter((value) => {
        return value.indexOf(firstName) !== -1 ? true : false;
      });
    });
  
    addMethod(people, 'find', function(firstName, lastName) {
      return this.values.filter((value) => {
        var fullName = `${firstName} ${lastName}`;
        return value.indexOf(fullName) !== -1 ? true : false;
      });
    });
  
    // console.log(people.find());                     // ["Dean Edwards", "Sam Stephenson", "Alex Russell", "Dean Tom"]
    // console.log(people.find('Dean'));               // ["Dean Edwards", "Dean Tom"]
    // console.log(people.find('Dean', 'Edwards'));    // ["Dean Edwards"]
  ```

  

- React 生命周期

  https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

  分为三个阶段，有两个生命周期新增

- 数组去重

  - []
  - {}，使用 es6 map 进行改进

- ❌es5,es6如何实现继承

  ```javascript
  function Person(age, name){
    this.age = age
    this.name = name
  }
  Person.prototype.sayName = function(){
    console.log(`你好我是${this.name}`)
  }
  
  
  function Student(age, name, grade){
    // 这句话的意思: 借用 Person 这个函数
    // 这句话的作用: 继承 Person 定义的属性
    Person.call(this, age, name)
    this.grade = grade
  }
  
  // 作用: 继承 Person 的方法
  function temp(){}
  temp.prototype = Person.prototype
  Student.prototype = new temp() 
  
  
  let s1 = new Student(18, 'rjj', '初一')
  s1.sayName()
  console.log(s1);
  ```



- new 操作做了什么

  - 生成对象：生成临时对象 tempObj

  - 指向共有属性：令 `tempObj.__proto__ === Test.prototype`
  - 执行构造函数执行 Test 函数，并且内部的 this 指向 tempObj

  - 进行判断，如果无返回值或者返回一个非对象值，则将 tempObj 作为返回值返回出去；如果返回一个对象值，那么将该对象作为返回值返回出去。
    [例子](https://jsbin.com/hakiwomuno/1/edit?js,console,output)

- js 类数组转化为数组

  `Array.prototype.slice.call(likeArray)`

- 如何判断数据类型



