## 2020.12.19

- 



## 2020.12.18





## 2020.12.17

- 查找文件

  ```sh
  find / --name xxx.js
  ```

  /etc/nginx/html/xhz3d

- 查找文件内容

  ```
  grep xxx -r .
  ```

- 取消导出
  点击取消导出后，按钮没有反应http://zentao.bimwinner.com/zentao/bug-view-10346.html

  http://zentao.bimwinner.com/zentao/bug-view-10347.html

  点击重新导出 => 点击取消导出，按钮没有反应http://zentao.bimwinner.com/zentao/bug-view-10347.html

- 点击导入数据包之后，需要判断

  导入组件不一致数据包，应该提示组件不匹配；然后选择组件一致数据包，应该可以正常导入http://zentao.bimwinner.com/zentao/bug-view-10348.html

  http://zentao.bimwinner.com/zentao/bug-view-10359.html

  未做提示信息判断：http://zentao.bimwinner.com/zentao/bug-view-10361.html

- ui
  导入成功后，应该显示重新导入，而不是开始导入http://zentao.bimwinner.com/zentao/bug-view-10352.html

  删除即可http://zentao.bimwinner.com/zentao/bug-view-10355.html

- 在导入、导出过程中，需要保存导入导出状态http://zentao.bimwinner.com/zentao/bug-view-10358.html

  

- 导入操作

  - 上传完毕后点击开始导入按钮（不同组件），显示 /restore 接口的报错
  - 正在上传中，没有显示上传中http://zentao.bimwinner.com/zentao/bug-view-10367.html
  - 重新上传相同组件，可以正常导入
  - bug: 先导入组件不一致，在导入组件一致；「豪华 1」先上传不一致组件，再上传一致组件，一致组件提示组件不一致
  - 查看appTransferRecord 接口，看下有没有 attention 字段

  - 解决：http://zentao.bimwinner.com/zentao/bug-view-10348.html 、 http://zentao.bimwinner.com/zentao/bug-view-10359.html 、 http://zentao.bimwinner.com/zentao/bug-view-10361.html
  - 查看是不是重新导入
  - 解决：http://zentao.bimwinner.com/zentao/bug-view-10352.html





## 2020.12.16

- xhz

  研发：

  alpha.zhuanspace.com 社区域名
  alpha-platform.zhuanspace.com 开放平台
  alpha-admin.zhuanspace.com 社区后台管理系统
  alpha-admin-platform.zhuanspace.com 开放平台后台管理系统
  alpha-consul.zhuanspace.com  注册中心
  alpha-bingodb.zhuanspace.com  数据库
  alpha-api.zhuanspace.com 接口调用地址
  alpha-websocket.zhuanspace.com webSocket调用地址
  alpha-image.zhuanspace.com 静态资源
  alpha-statistic.zhuanspace.com 统计页面
  alpha-parse.zhuanspace.com 解析调用
  alpha-route.zhuanspace.com 路网调用
  alpha-vis.zhuanspace.com 三维
  alpha-webapi.zhuanspace.com 对外开放2.0接口地址
  api.zhuanspace.com 对外开放1.0接口地址 已经停止维护。所以环境统一使用一个域名

- 

## 2020.12.15

- 点击导出，立刻点击取消导出，重新导出发现无法获取

- 柯里化

  - 定义：将使用多个参数的一个函数转换成一系列使用一个参数的函数

  - 用途：参数复用

  - 定义柯里化函数

    ```
    	function ajax(url, headers, data){
    	  console.log('ajax 开始请求----');
    	  console.log(url, data, headers);
    	  console.log('ajax 结束请求----');
      }
    	
    	
    	/*
    	1. 最简单的实现
    	 */
    	// ajax('http://api/person', {auth: 2}, {id: 1})
      // ajax('http://api/order', {auth: 3}, {id: 1})
    
      /*
    	2. 很简单的函数封装
     */
    	// 函数定义
    	function getPerson(headers, data){
    	  ajax('http://api/person', headers, data)
    	}
      function getOrder(headers, data){
    	  ajax('http://api/order', headers, data)
      }
      // 函数使用
      // getPerson( {auth: 2}, {id: 1})
      // getOrder( {auth: 2}, {id: 1})
    	
    	/*
    	3. 问题: 如果我们知道 url 和 data, 那么 getPerson 函数失效,需要重新写一个函数,这样不好
    	 */
    	
    	/*
    	4. 定义 partial 函数
    	 */
    	function partial(fn, ...preArguments){
    			return function(...lastArguments){
    				fn(...preArguments, ...lastArguments)
    			}
    	}
    	var getPerson1 = partial(ajax, 'http://api/person', {auth: 1})
      // getPerson1({id: 123321})
    	
    	/*
    	5. 另一种解决方法: curry 
    	*/
    function curry(func) {
    
      return function curried(...args) {
        if (args.length >= func.length) {
          return func.apply(this, args);
        } else {
          return function(...args2) {
            return curried.apply(this, args.concat(args2));
          }
        }
      };
    
    }
    
    
      var curriedAjax = curry(ajax)
      var personFetcher = curriedAjax( "http://some.api/person" )
      var getCurrentUser = personFetcher( { auth: 1 } )
      getCurrentUser( {id: 2} );
    ```

    

  - 应用

    - https://juejin.cn/post/6844903592835432455

  - https://juejin.cn/post/6844903633751031822

## 2020.12.14

- 需求：点击应用，在模态框显示选择应用的信息，解决方案改进过程

  - 使用变量保存用于选择应用信息，手动调用 render 函数

    ```
    let appKey = ''
    let fileReq = []
    let uploadPercentage = 0
    
    // 1. 点击应用，修改 appKey, fileReq, uploadPercentage 值
    // 2. 手动执行 render ，根据现appKey, fileReq, uploadPercentage渲染 ui
    // 问题 1：需要多个位置调用 render 函数 
    // 问题 2：切换不同应用，可能导致渲染数据错乱
    
    ```

  - 改进方法

    - 使用构造函数创建应用数据实例，每一个appKey 对应数据实例，互相数据不会污染
    - 创建修改实例数据的方法，在这个函数执行 render 操作

    

    

  

- prettier 的使用，保证三个点：①能修改配置②提交执行 prettier 代码 ③git 提交能保存之前的用户（希望能实现）

- e.target vs e.currentTarget

## 2020.12.11

- 

## 2020.12.10

- 多应用导入功能实现

  - 使用

    ```
    {
    	"appKey1": {
    					file: null, // 保存文件变量
    			hash: "", // 文件hash
    			sliceKey: '', // 保存 verifyUpload 接口返回的 sliceKey
    						data: [],
    			status: Status.wait,
    			fakeUploadPercentage: 0,
    			resMessage: '', // 后端返回的信息
    			importPercentage: 0,
    	},
    }
    ```

    进行操作，点击某个应用的时候，current 指向 appKey 对应对象

    修改值，需要使用current.set('file', fjdkalsfjdka)

    并且在 set 的时候，执行 renderUI 函数（会有重复渲染的问题）

    使用值，需要使用 current.file

  

  

  



## 2020.12.08



## 2020.12.05

- proxy 设计思想：监听「对象set、get操作」，执行预定事件。与「发布-订阅设计模型」没有区别？
- 数据需要考虑
- proxy demo 需求
  - 创建一个银行账号对象，存有账号名称和余额
  - 当获取余额时，需要打印查询余额时间
  - 当设置余额时，需要检查余额不能为负数；并且需要将当前余额打印到页面上
  - 当获取计算属性（美元），需要使用缓存减少计算计算属性计算
- 



## 2020.12.04

- 上传进度数据获取
  使用闭包传递数据

  ```javascript
  window.array = [{number: 1}, {number: 2}, {number: 3}, {number: 4}];
  function handle(e){
    console.log(e);
    // 需求: 在这里能获取 array item 数据
  }
  
  // 在函数1定义处返回一个函数2，函数1 的参数就是需要传递的数据，函数 2 的参数就是事件返回的对象
  function handle1(obj){
    return (e)=>{
      console.log(obj);
      console.log(e);
    }
  }
  array.forEach((obj)=>{
    btn.addEventListener('click', handle)
    btn.addEventListener('click', handle1(obj))
  })
  ```

- 暂停功能实现

  - 核心：xhr 请求对象有 abort 方法，调用即可取消请求

  - 将所有上传切片请求的 xhr 对象放入数组1

  - 监听 xhr 完成事件，将已经完成 xhr 从数组 1 删除

  - 用户点击暂停按钮，对数组 1 进行遍历，执行 xhr 对象的 abort 函数

    

- 继续功能实现

  - 点击继续按钮，运行下 verifyUpload 函数，获取已经上传的切片文件列表chunkList

  - 在上传函数uploadChunks 中，使用「已经上传文件列表 chunkList」 + 「前端生成文件列表」得到「真正需要上传的切片文件」

    

- bug 修复思路回顾

  - bug 现象：点击模型管理左侧树，进行展开操作，选择其他组件，再选择模型管理组件，发现模型管理左侧树组件无法展开
  - bug 原因：模型管理树组件componentDidMount只执行一次，后续不会再执行，按照正常情况应该进入模型管理组件后执行componentDidMount 函数
  - bug 解决思路：
    - 查看「模型管理树组件」使用的组件 1，在组件 1 的 componentDidMount 是不是也执行一次，发现是的
    - 查看组件 1 使用的地方
      ![image-20201204174817827](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/iamge-host-2/master/image-20201204174817827.png)

## 2020.12.03

- 使用主站接口进行请求，使用 test 代码
- vue 上传
  - 发送接口判断文件之前是否上传过
  - 前端对文件进行切片
  - 将切片传输到服务器
  - 发送合并请求（可选）
  - 计算上传进度
  - 



## 2020.12.02

- 点击导入导出按钮显示模态



## 2020.12.01

- 前端对大文件进行切片 createFileChunk

  输入 file 对象，输出数组，item 是{file: fileChunk}

  使用`file`对象的`slice`方法

  使用到 while 循环，与事件代理，instanceOf 实现都是一样的

  while 循环：只知道循环的终点，

- node.js 处理文件上传功能时，如何将上传的文件移动到服务器某个目录？

  使用 mv 操作

- 如何使用 node 将多个文件进行文件合并

- `path.resolve + __dirname`  === es6 import 、 export

  `__dirname` === 文件所在的目录

- 研发环境

  ```
  const bosapp = {
  	appKey:'${appKey}',
  	appName: '${appName}',
  };
  bosapp.baseUrl='https://bigbos-alpha.bimwinner.com';
  bosapp.host=bosapp.baseUrl+bosapp.appKey;
  bosapp.binsideUrl = 'https://bos3d-alpha.bimwinner.com';
  bosapp.binsideVersion = 'api';
  bosapp.bos3dViewerUrl = 'https://bos3d-alpha.bimwinner.com';
  ```

- 生产

  ```
  const bosapp = {
  	appKey:'${appKey}',
  	appName: '${appName}',
  };
    bosapp.baseUrl='${template_api_base}';
    bosapp.host=bosapp.baseUrl+bosapp.appKey;
    bosapp.binsideUrl = '${template_binsideUrl}';
    bosapp.binsideVersion = 'api';
    bosapp.bos3dViewerUrl = '${template_bos3dViewerUrl}';
  ```

  