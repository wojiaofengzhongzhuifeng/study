# 继承

## 实现继承方法

### 1. 原型链继承

思路：子构造函数（Student）的 prototype 指向父构造函数（Person）的实例

代码：https://jsbin.com/leforiponu/1/edit?js,console,output

🌟⭐图示继承重点：

![](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/image-host/master/img/20190516145755.png)

对应的图示是

![](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/image-host/master/img/20190516142623.png)

缺点

 1. 属性是引用类型，实例之间相互影响

    如果父构造函数类型（Person）的实例属性是引用类型（body）， 那么每个子构造函数（Student）的实例对象A，实例对象B的实例属性（body）都会互相影响。

2. 无法传递参数

   创建子构造函数（Student）的实例，不能向父构造函数（Person）中传递参数（name）。

### 2. 借用构造函数

思路：调用父构造函数，继承父构造的实例属性

代码：https://jsbin.com/nicobusava/1/edit

缺点：只能继承实例属性，无法继承公共方法

### 3. 组合继承

思路：使用原型链，继承父构造函数的公共属性；借用构造函数，继承父构造函数的实例属性

代码：https://jsbin.com/miripucafa/1/edit

缺点：调用两次父构造函数

### 4. 原型继承

🚧

### 5. 寄生式继承

🚧

### 6. 寄生组合式继承

🚧

### 7. ES5 完美的继承

思路：以组合继承为基础，更好的实现继承

代码：https://jsbin.com/febasodaxi/1/edit?js,console,output

## new 做了什么？

1. 生成对象：生成临时对象 tempObj
2. 指向共有属性：令 `tempObj.__proto__ === Test.prototype`
3. 执行构造函数执行 Test 函数，并且内部的 this 指向 tempObj
4. 进行判断，如果无返回值或者返回一个非对象值，则将 tempObj 作为返回值返回出去；如果返回一个对象值，那么将该对象作为返回值返回出去。
       


[例子](https://jsbin.com/hakiwomuno/1/edit?js,console,output)



### 问题

1. 组合继承/完美继承时， 为什么不直接Student.prototype = Person.prototype，而是要Student.prototype = new Person() / new F()？

   Student.prototype.study 的 study 方法会在 Person，而不是 Student 中

   https://jsbin.com/kugogogugo/1/edit?js,console,output











