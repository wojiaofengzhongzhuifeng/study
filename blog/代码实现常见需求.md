# 代码实现需求



## 防抖和节流
### 节流 （技能冷却时间）
  - 实现思路：设置一个flag
  - 使用场景：一段时间，只能执行一次代码
  - [例子](https://jsbin.com/giralanuki/1/edit?html,js,console,output)
### 防抖（等待一段时间，一起做）
 - 实现思路：定时器内总是保存最新的定时器
 - 使用场景：等你一段时间不再触发，我再执行
 - [例子](https://jsbin.com/behunokime/edit?html,js,output)
### 区别

  首先，两者的目的都是防止重复调用代码
  但是，两者实现目的的方法不同
  节流：限制时间，给定一段时间，只能在一段时间内执行一次代码
  防抖：限制频率，等你不动了，我隔一段时间再执行代码







## 对象拷贝

![](https://raw.githubusercontent.com/wojiaofengzhongzhuifeng/image-host/master/img/20190518100432.png)

#### es6的对象复制
1. `Object.assign` 浅拷贝
2. `扩展运算符` 浅拷贝

#### 实现一个深拷贝（有bug）
[递归 + 判断类型实现深拷贝](https://jsbin.com/cofevazaci/1/edit?js,console,output)







## 数组拍平，去重，排序

### 数组拍平

#### 思路

使用 concat + 递归实现

`array12 = array12.concat(flat(item))`

### 去重

#### 其他方法

1. indexOf去重(推荐！)

   新建一个 array，使用 indexOf 判断，如果不在 array 中，就 push 进去

   https://jsbin.com/qupimiqoju/1/edit?js,console,output

2. 对象属性去重(bug：得出来的是 string)

   新建一个对象，对象的 key 就是 array 的值

   https://jsbin.com/dixefugoni/1/edit

3. ES6 set 数据结构

   https://jsbin.com/quposulora/1/edit

   https://jsbin.com/xekojimayi/1/edit?html,js,console,output



### 三者一起使用

[例子](https://jsbin.com/nuyeficaba/1/edit)

## 函数柯里化



## 获取 url 的所有参数



## 斐波那契数列

[例子](https://jsbin.com/solehacopo/1/edit?js,console,output)



## 事件委托
[例子](https://jsbin.com/peditemope/1/edit?html,js,console,output)



## 一维数组与嵌套数组转化

- [一维数组转嵌套数组](https://jsbin.com/gexabiyuqu/1/edit?js,console,output)

  思路：

  - 添加一个 object，该 object 的 key 是 id，value 是 item。
  - 这个 object 可以完成 『获取 item， 并且获取 item 的父 item』

## eventBus

- https://jsbin.com/pecexaroxi/1/edit?js,console,output

  思路：

  - on    函数根据事件名称，注册回调函数
  - emit 函数根据事件名称，执行回调函数(带上 data)





## 获取数组最大值

- Math.max + ES6 展开参数`Math.max(...[1,2,3,5])`